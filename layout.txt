Layout
------

So I have a basic graph grammar and force based graph drawing level gen system.

The limits on the graph grammar rules are:
- Only start rules can have one vertex in the pattern, which must be tagged 's'.
- No 's' tagged vertices can appear in substitute graphs.
- All non-start rules must be context-senstive, i.e. have more than one vertex
- All pattern and substitute graphs must be connected.
- There must be a bijective map from pattern vertices to susbstitute vertices.
  - So the number of substitute vertices is >= the number of pattern vertices.
- Pattern vertices (but not substitute or host vertices) have a tag set, so
  they can match more than one different host graph tag.
- There is a maxValence parameter that stops rules from exceeding it. However
  if a substitute graph has a greater valence it can still be used.

Some points on the algorithm used:

- The subgraph matches have to be whittled down to avoid a problem with
  'flipped' patterns. For example consider a triangle pattern graph:

  a - b
    \ |
      b

  There are two ways this can be mapped to a host graph. One of the matches is
  a 'rotation' the other is a 'flipped' rotation because the b tagged vertices
  can be mapped in either order. I use the signed angle between edges to
  eliminate the flipped matches (graph.spurs() calculates them). Flipped
  matches cause a problem because when the neighbourhood edges are
  re-established they will intersect the subsitute and the graph drawing cannot
  fix the issue reliably.

- The substitute vertices that are mapped to pattern vertices take the
  positions of the host graph vertices. The 'fresh' vertices introduced in a
  substitute graph are created relative to an edge in the pattern graph. This
  is essentially a 'rotation and scale'. This is why non-start rules must be
  context sensitive, to allow an edge to be used as a basis.

- The current editor forces the positions of mapped subsitute vertices to be
  similar to their pattern vertices. This isn't checked in the rules but is
  implcitly assumed by the flip detection logic.

- The force based graph drawing is the slowest part of the process by a very
  large margin. Not sure how much scope there is for optimising it either.

  May be able to use more aggressive paramters (higher maxDelta) if the
  upscaling insertion mentioned below is implemented.

  NOTE: While it is still the slowest part if you run it as fast as possible
        (no yielding) it is actually very fast.

Some ideas for future work:

- The force based graph drawing seems to be a lot better at 'contracting'
  graphs than expanding them. So it might be worth scaling up the entire graph
  when inserting new subgraphs to avoid overlapping issues.

  This may be due to the log based spring calculation. Short edges are very
  forcefully pushed out but long edges are smoothly pulled closer. It might be
  worth experimenting with a sigmoid function based spring instead.

  NOTE: I tried scaling the graph out and it had a strange result. It made the
        graph stretch out and look quite bad. I think it might be due to the
        log based spring forces being overwhelmed by the inverse square
        repulsion forces.

- Because the graph drawing algorithms tends to straigten everything out we
  need to be able to add cosmetic edges (to constrain the shape) that will not
  become corridors. The connectivity pre-conditions of the rules need to take
  this into account (so you can't split a level with a cosmetic edge).

  Also cosmetic edges should not be matched with non-cosmetic edges. Can use
  the edgeEq parameter to Graph:matches() to enforce this.

- When rooms are created for the vertices we'll need to scale up the graph to
  fit them without overlaps. This could be done by setting per-edge length
  factors that multiply the base desired edge length in graph drawing.

  Could use the same feature in the rules to control edge lengths, especially
  useful for cosmetic edges one would think. For example we could calculate the
  proportionate edge length in the substitute graph as a multiplier for edge
  lengths. This would make subdividing rules smaller.

  NOTE: this has been implemented in a basic way (the rooms are modelled as
        circles).

- Optional valence check on mapped vertices. If a substitute vertex has the
  option enabled it only allows it to be applied if the host vertex has the
  same valence as in the pattern graph. See the issue below about tassles for
  the motivation.

  NOTE: Tried this and it's not very useful. See below in tassles.

- A few times it would have been useful to specify a set of tags in the pattern
  instead of just a single tag. For example a vertex tagged '*' could match any
  other vertex. A vertex tagged 'a|b' could match to vertices tagged as either
  'a' or 'b'. (Wonder whether 'anything but a or b' is needed...)

  UI: If you hold shift while pressing a key for the vertex add it to the tag
      set. Without shift just replace with a singleton tag set.

  This does raise an issue about what tag the substitute should have when
  mapped to a tag set. A simple solution is to say that it keeps the tag it has
  in the host graph, e.g.

  host: a -- b 
  rule: * - * => * - * - c

  Could create:

  a - b - c  or c - a - b

  But it would be possible to override it as well. Need to be able to undo an
  overridden vertex tag though.

  NOTE: this has been partially implemented.


Some unresolved issues:

- It's easy to cause issues by connecting edges in the substitute graph that
  aren't connected in the pattern, e.g.

  a - b     a - b
      |  =>   \ |
      c         c

  It can easily create 'knots' that the graph drawing can't undo. Might be
  worth stopping this from happening by adding another condition on the rules.

  Actually this is sometimes very useful, so caveat emptor.

- Substitute graphs can intersect other parts of the host graph which get fixed
  only some of the time by the graph drawing code. The upscaling idea mentioned
  above might solve this though.

- It's too easy to create 'tassles', e.g.

  a - b     a - b
    \ |  =>   \ |
      b         b - c

  The above can be matched to the same part of the host graph many times so you
  can get a lot of 'c' vertices hanging off the same 'b' vertex. Could be fixed
  by changing the tag of the 'b' vertex that 'c' is attched to though.

  This issue also made me consider a rule that any vertex that changes valence
  in the substitute must have the same valence in the host graph as it does in
  the pattern. This would stop tassles but also make obviously fine rules not
  work as intended, e.g.

               b
              / \
  a - a  =>  a   a
              \ /
               b

  The 'a' vertices increase in valence but so this rule could only be applied
  to a host graph that looked exactly like the pattern graph.

  Could add the valence rule as a optional vertex attribute though. In fact I
  think this might be the best solution...

  Actually this isn't a great solution. You need to add a lot of extra guff to
  the pattern graph to make it work, which reduces flexibility.

  A better solution might be something I've seen in a few graph grammar systems
  where you can specify vertices that shouldn't be in the host, e.g.

  a - b         a - b
    \ |      =>   \ |
      b - !c        b - c

  The !c means don't match if there's a c tagged vertex connected to the lower
  'b' vertex. This will be tricky to implement though:

  - The blocked nodes shouldn't appear in the actual matching graph otherwise
    it will only match graphs with an extra neighbour but just only if it's not
    tagged as 'c'.
  - The following case could cause issues:

    a - b         a - b
      \ |      =>   \ |
        b - !b        b - b

    The matching would have to be able to distinguish between the higher b in
    the pattern and the blocked b.

  So here's a rough algorithm:
  - A pattern vertex is allowed only one blocked neighbour and a blocked
    vertex can only be attached to one non-blocked vertex.
  - Allow an extra argument to the rules that is a map from pattern vertices to
    a blocked peer tag (or tag sets).
  - In GraphGrammer.Rule:matches() there's a filtering step.
    - If the rule has any blocked vertices.
      - Find the edges in the host not matched.
        - For all matched vertices
          - Is their a peer of the graph vertex not in the match
            - Add the edge to the unmatched peer to the list.

- Sometimes the valence of vertices gets too high for the graph drawing to
  handle, e.g.

  a - b     a - b
    \ |  => | \ |
      b     b - b

  Can subdivide add an extra spoke to a 'wheel' of triangles indeifnitely.
  Eventually the circumference of the wheel will collapse and edges start
  intersecting. May be worth adding a maxValence paramter to the builder so
  that this isn't allowed to happen. In any case we don't want the valence to
  get too high for gameplay reasons anyway.

  Could be a per-vertex attribute I suppose but feels a little untidy.

  Also I think the cause of the issue is that the spring forces in the graph
  drawing are very strong when the edge is too short. This pushes other edges
  into overlapping positions.

- What about setting edge length factors at the end of each force draw?

- There is an issue with subdividing rules. Because the desired edge length for
  all edges is the same it is common for the 'inside' vertices of a subdivding
  substitute graph to be pushed outside.

  It would be possible to control this with a per-edge 'length factor' that
  multiplies the base desired edge length. If the internal edges of the
  substitute graph have length factors less than 1 it should hold the internal
  vertices in place.

  One problem with that is that rules can be recursively applied and length
  factors are absolute. So if a subdividing rule is applied twice the same
  problem will reappear.

  One possible solution is to copy the length factor for mapped edges (i.e.
  edges in the substitute whose vertices are mapped and the edge exists in the
  pattern). But for unmapped edges we base the length factor on the mean edge
  length in the pattern.

  So in the graph editor we calculate the avage length of lines in the pattern.
  Then for each 'subdivided' edge in the substitute we can get the length
  factor by:

      lengthFactor = edgeLength / meanPatternEdgeLength

  If the rule is a start rule (so no edges in the pattern) use the mean length
  for the subsitute instead.

  If the edge is not marked as 'subdivided' the length factor is 1.

  When inserting edges into the host graph we find the mean length of the edges
  in the host mapped by the pattern graph. We then divide it by the edgeLength
  passed into the forceDraw stage to get the meanHostLengthFactor.

  When adding substitute edges we have the following properties:
  - Mapped. The vertices substitute edge are both mapped and an edge exists
    btween them in the pattern.  
  - Subdivided edge. The susbstitute edge is marked as subdivided and has a
    length factor specified.
  - NOTE: can a mapped edge be subdivided? Does it matter if it is?
    - Mapped edges should always take the length factor from the host.
  - Not mapped and not subdivided edge.

  - For mapped edges we use the length factor of the host edge we're replacing.
  - For subdivided edges we need to calul


  For mapped edges we copy the length
  factor from the host graph. For subdivided edges we 