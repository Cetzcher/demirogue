Layout
------

I'm having issues trying to come up with a more controlled layout generation
system that doesn't need either a graph drawing algorithm (slow and imperfect)
or provides the right mix of control and generative power.

Maybe looking at some simpler systems in more detail would help:

- Automatic GUI style layout system based on tree-of-boxes and tree-grammars.

- The main restriction on any system is that it produces graphs that can be
  rendered and have certain properties.
  - Planar graphs in the 2D case.
  - Size restrictions.

 Here's some pseudo-code for a box based graph rendering algorithm

 function layout( node, margin )
 	if node.leaf then
 		node.points = gen(node)
 		local aabb = bounds(node.points)
 		node.width, node.height = aabb:width(), aabb:height()
 	else
 		local maxWidth = 0
 		local maxHeight = 0

 		for _, child in ipairs(node.children) do
 			layout(child)
 			maxWidth = math.max(node.width, maxWidth)
 			maxHeight = math.max(node.height, maxHeight)
 		end

 		if node.horz then
 			-- We centre the nodes within the max height.
			for child in pairs(node.children) do

 			end 			
 		elseif node.vert then

 		end
 	end

 	if node.root then
 	end
 end






Graph Grammar Rules
- Planarity: the left and right hand of rules must be planar.
- Conext sensitive: graphs can be on the left side of rules, not just nodes.
  - Gives more control and expressive power to the designer.
- Connected: both the left and right hand graphs in rules must have a single
             connected component.
- Generative/Projective: the right hand of rules can only add to the left hand.
  - Removing nodes or massively changing topology make rendering a lot harder.
- Non-colliding: any vertex that has added neighbours in the right hand rule
                 must have the exact valence described in the left hand rule.
  - This avoids the following issue

  1: A -- B => A -- C -- B
                    |
                    D

Problem
-------

S1 --- F1 =>  S1 --- R1
               |     |
               |     |
              R2 --- F1


Action points.
--------------

1. Implement context-free box grammar and generator.
2. Implement context-sensitive box grammar and generator.
3. 

- Need planarity testing for grammar rules.
  - There are linear algorithms, not sure how complex though.
- Need subgraph matching for grammar rules.
  - There are planar graph matching algorithms but I think they use the
    placements of the edges.
    - Eppstein's planar subgraph isomorphsim doesn't use a planar
      representation. It is very complex though.


Basic Rule Editor
-----------------

- Theme
  - Rule
    - Pattern
    - Substitute


+-------------------------------------------------+
|theme - rule            |                        |
|                        |                        |
|                        |                        |
|                        |                        |
|                        |                        |
|                        |                        |
|                        |                        |
|                        |                        |
|                        |                        |
|                        |                        |
|                        |                        |
|                        |                        |
|                        |                        |
|                        |                        |
|                        |                        |
+-------------------------------------------------+

a new force-directed graph drawing method based on edge-edge repulsion
- interesting paper, nice results.


Just got a great idea from talking to Phil.
- Use an incremental force based graph drawing.
  - The rules have to have coordinates.
  - These are used to stitch in the new verts and edges.
  - Then run a force based drawing algorithm to convergence.
  - As long as new edges are not added overlapping previous ones it should look
    good.
    - Need to be able to transform from rule space to graph space.
    - Some know when inserting new edges whether they overlap and if so scale
      down in some way.
      - Calculate the host space centroid of the pattern graph.
      - Remove pattern verts and edges from the host graph.
      - Create bounding geometry (AABB, circle, hull) for the right hand side.
      - Rotate point the right direction.
        - This is the trickiest step I think.
          - May be possible to derive it if the left-hand rule is context
            sensitive. Could use an edge to orient things.
      - Query the host graph with the rotated bounding geometry.
        - Scale down to avoid any vertices or edges.
      - Insert scaled down substitute vert and edges.
      - Reattach to host graph.
      - Run force directed algorithm to covergence.
      - Transform the 
      - If any other