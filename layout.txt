Layout
------

So I have a basic graph grammar and force based graph drawing level gen system.

The limits on the graph grammar rules are:
- Only start rules can have one vertex in the pattern, which must be tagged 's'.
- No 's' tagged vertices can appear in substitute graphs.
- All non-start rules must be context-senstive, i.e. have more than one vertex
- All pattern and substitute graphs must be connected.
- There must be a bijective map from pattern vertices to susbstitute vertices.
  - So the number of substitute vertices is >= the number of pattern vertices.

Some points on the algorithm used:

- The subgraph matches have to be whittled down to avoid a problem with
  'flipped' patterns. For example consider a triangle pattern graph:

  a - b
    \ |
      b

  There are two ways this can be mapped to a host graph. One of the matches is
  a 'rotation' the other is a 'flipped' rotation because the b tagged vertices
  can be mapped in either order. I use the signed angle between edges to
  eliminate the flipped matches (graph.spurs() calculates them). Flipped
  matches cause a problem because when the neighbourhood edges are
  re-established they will intersect the subsitute and the graph drawing cannot
  fix the issue reliably.

- The substitute vertices that are mapped to pattern vertices take the
  positions of the host graph vertices. The 'fresh' vertices introduced in a
  substitute graph are created relative to an edge in the pattern graph. This
  is essentially a 'rotation'. This is why non-start rules must be context
  sensitive, to allow an edge to be used as a basis.

- The current editor forces the positions of mapped subsitute vertices to be
  similar to their pattern vertices. This isn't checked in the rules but is
  implcitly assumed by the flip detection logic.

- The force based graph drawing is the slowest part of the process by a very
  large margin. Not sure how much scope there is for optimising it either.

  May be able to use more aggressive paramters (higher maxDelta) if the
  upscaling insertion mentioned below is implemented.

Some ideas for future work:

- The force based graph drawing seems to be a lot better at 'contracting'
  graphs than expanding them. So it might be worth scaling up the entire graph
  when inserting new subgraphs to avoid overlapping issues.

  This may be due to the log based spring calculation. Short edges are very
  forcefully pushed out but long edges are smoothly pulled closer. It might be
  worth experimenting with a sigmoid function based spring instead.

- Because the graph drawing algorithms tends to straigten everything out we
  need to be able to add cosmetic edges (to constrain the shape) that will not
  become corridors. The connectivity pre-conditions of the rules need to take
  this into account (so you can't split a level with a cosmetic edge).

  Also cosmetic edges should not be matched with non-cosmetic edges. Can use
  the edgeEq parameter to Graph:matches() to enforce this.

- When rooms are created for the vertices we'll need to scale up the graph to
  fit them without overlaps. This could be done by setting per-edge length
  factors that multiply the base desired edge length in graph drawing.

  Could use the same feature in the rules to control edge lengths, especially
  useful for cosmetic edges one would think. For example we could calculate the
  proportionate edge length in the substitute graph as a multiplier for edge
  lengths. This would make subdividing rules smaller.

- Optional valence check on mapped vertices. If a substitute vertex has the
  option enabled it only allows it to be applied if the host vertex has the
  same valence as in the pattern graph. See the issue below about tassles for
  the motivation.

  NOTE: Tried this and it's not very useful. See below in tassles.

- A few times it would have been useful to specify a set of tags in the pattern
  instead of just a single tag. For example a vertex tagged '*' could match any
  other vertex. A vertex tagged 'a|b' could match to vertices tagged as either
  'a' or 'b'. (Wonder whether 'anything but a or b' is needed...)

  UI: If you hold shift while pressing a key for the vertex add it to the tag
      set. Without shift just replace with a singleton tag set.

  This does raise an issue about what tag the substitute should have when
  mapped to a tag set. A simple solution is to say that it keeps the tag it has
  in the host graph, e.g.

  host: a -- b 
  rule: * - * => * - * - c

  Could create:

  a - b - c  or c - a - b

  But it would be possible to override it as well. Need to be able to undo an
  overridden vertex tag though.


Some unresolved issues:

- It's easy to cause issues by connecting edges in the substitute graph that
  aren't connected in the pattern, e.g.

  a - b     a - b
      |  =>   \ |
      c         c

  It can easily create 'knots' that the graph drawing can't undo. Might be
  worth stopping this from happening by adding another condition on the rules.

- Substitute graphs can intersect other parts of the host graph which get fixed
  only some of the time by the graph drawing code. The upscaling idea mentioned
  above might solve this though.

- It's too easy to create 'tassles', e.g.

  a - b     a - b
    \ |  =>   \ |
      b         b - c

  The above can be matched to the same part of the host graph many times so you
  can get a lot of 'c' vertices hanging off the same 'b' vertex. Could be fixed
  by changing the tag of the 'b' vertex that 'c' is attched to though.

  This issue also made me consider a rule that any vertex that changes valence
  in the substitute must have the same valence in the host graph as it does in
  the pattern. This would stop tassles but also make obviously fine rules not
  work as intended, e.g.

               b
              / \
  a - a  =>  a   a
              \ /
               b

  The 'a' vertices increase in valence but so this rule could only be applied
  to a host graph that looked exactly like the pattern graph.

  Could add the valence rule as a optional vertex attribute though. In fact I
  think this might be the best solution...

  Actually this isn't a great solution. You need to add a lot of extra guff to
  the pattern graph to make it work, which reduces flexibility.

  A better solution might be something I've seen in a few graph grammar systems
  where you can specify vertices that shouldn't be in the host, e.g.

  a - b         a - b
    \ |      =>   \ |
      b - !c        b - c

  The !c means don't match if there's a c tagged vertex connected to the lower
  'b' vertex. This will be tricky to implement though:

  - The blocked nodes shouldn't appear in the actual matching graph otherwise
    it will only match graphs with an extra neighbour but just only if it's not
    tagged as 'c'.
  - The following case could cause issues:

    a - b         a - b
      \ |      =>   \ |
        b - !b        b - b

    The matching would have to be able to distinguish between the higher b in
    the pattern and the blocked b.

  So here's a rough algorithm:
  - A pattern vertex is allowed only one blocked neighbour and a blocked
    vertex can only be attached to one non-blocked vertex.
  - Allow an extra argument to the rules that is a map from pattern vertices to
    a blocked peer tag (or tag sets).
  - In GraphGrammer.Rule:matches() there's a filtering step.
    - If the rule has any blocked vertices.
      - Find the edges in the host not matched.
        - For all matched vertices
          - Is their a peer of the graph vertex not in the match
            - Add the edge to the unmatched peer to the list.

- Sometimes the valence of vertices gets to high for the graph drawing to
  handle, e.g.

  a - b     a - b
    \ |  => | \ |
      b     b - b

  Can subdivide add an extra spoke to a 'wheel' of triangles indeifnitely.
  Eventually the circumference of the wheel will collapse and edges start
  intersecting. May be worth adding a maxValence paramter to the builder so
  that this isn't allowed to happen. In any case we don't want the valence to
  get too high for gameplay reasons anyway.

  Could be a per-vertex attribute I suppose but feels a little untidy.
