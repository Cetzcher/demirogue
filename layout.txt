Layout
------

So I have a basic graph grammar and force based graph drawing level gen system.

The limits on the graph grammar rules are:
- Only start rules can have one vertex in the pattern, which must be tagged 's'.
- No 's' tagged vertices can appear in substitute graphs.
- All non-start rules must be context-senstive, i.e. have more than one vertex
- All pattern and substitute graphs must be connected.
- There must be a bijective map from pattern vertices to susbstitute vertices.
  - So the number of substitute vertices is >= the number of pattern vertices.
- Pattern vertices (but not substitute or host vertices) have a tag set, so
  they can match more than one different host graph tag.
- The value part of the tag set can either be true or false. True denotes what
  host graph vertex tags can be matched. False denotes that any host vertices
  attached via unmapped (edges not in the pattern) host edges should not have
  the tag.
- There is a maxValence parameter that stops rules from exceeding it. However
  if a substitute graph has a greater valence it can still be used.
- If a pattern vertex is tagged as '-' it is a wildcard that allows it to match
  any host vertex.
- If a substitute vertex is tagged as '-' (only allowed on mapped vertices) it
  means it uses the tag from the host graph.
- There are currently four parameters that control the graph building process:
  
  maxIterations: to cap the number of rule applications.
  minVerticex:   if the building process finishes or stalls with fewer than
                 this many vertices the process is considered 'failed'.
  maxVertices:   this is very exceeded for any reason, i.e. rules aren't even
                 applied if it would create enbough vertices to exceed it.
  maxValence:    rules are not allowed to be applied if this value would be
                 exceeded for any vertex.


Some points on the algorithm used:
----------------------------------

- The subgraph matches have to be whittled down to avoid a problem with
  'flipped' patterns. For example consider a triangle pattern graph:

  a - b
    \ |
      b

  There are two ways this can be mapped to a host graph. One of the matches is
  a 'rotation' the other is a 'flipped' rotation because the b tagged vertices
  can be mapped in either order. I use the signed angle between edges to
  eliminate the flipped matches (graph.spurs() calculates them). Flipped
  matches cause a problem because when the neighbourhood edges are
  re-established they will intersect the subsitute and the graph drawing cannot
  fix the issue reliably.

- The substitute vertices that are mapped to pattern vertices take the
  positions of the host graph vertices. The 'fresh' vertices introduced in a
  substitute graph are created relative to an edge in the pattern graph. This
  is essentially a 'rotation and scale'. This is why non-start rules must be
  context sensitive, to allow an edge to be used as a basis.

- The current editor forces the positions of mapped subsitute vertices to be
  similar to their pattern vertices. This isn't checked in the rules but is
  implcitly assumed by the flip detection logic.

- The force based graph drawing is the slowest part of the process by a very
  large margin. Not sure how much scope there is for optimising it either.

  May be able to use more aggressive paramters (higher maxDelta) if the
  upscaling insertion mentioned below is implemented.

  NOTE: While it is still the slowest part if you run it as fast as possible
        (no yielding) it is actually very fast.

- After a graph has been successfully generated each vertex has a random radius
  assigned (the intention is to simulate different room sizes). Then for each
  vertex we calculate the ideal length of the edge (sum of their radii plus a
  small fudge factor). This ideal length is then compared to the current edge
  length and a scale value calculated.

  The entire graph is then scaled up by the largest scale factor (to ensure no
  vertex circles intersect). Then a force drawing step is performed to contract
  the edges towards their ideal.

  If the final graph passes a self-intersection test it should be suitable for
  use in generating actual level geometry.

Some ideas for future work:
---------------------------

- The force based graph drawing seems to be a lot better at 'contracting'
  graphs than expanding them. So it might be worth scaling up the entire graph
  when inserting new subgraphs to avoid overlapping issues.

  This may be due to the log based spring calculation. Short edges are very
  forcefully pushed out but long edges are smoothly pulled closer. It might be
  worth experimenting with a sigmoid function based spring instead.

  NOTE: I tried scaling the graph out and it had a strange result. It made the
        graph stretch out and look quite bad. I think it might be due to the
        log based spring forces being overwhelmed by the inverse square
        repulsion forces.

  NOTE: After some testing and more thought it seems to be due to the 'pull'
        force on overly long edges being very weak. It converges well before
        the long edges can be contracted.

- Because the graph drawing algorithms tends to straigten everything out we
  need to be able to add cosmetic edges (to constrain the shape) that will not
  become corridors. The connectivity pre-conditions of the rules need to take
  this into account (so you can't split a level with a cosmetic edge).

  Also cosmetic edges should not be matched with non-cosmetic edges. Can use
  the edgeEq parameter to Graph:matches() to enforce this.

  NOTE: Done, they are good for maintain shape sometimes. But tend to be
        problematic when subdivision is involved.

- Optional valence check on mapped vertices. If a substitute vertex has the
  option enabled it only allows it to be applied if the host vertex has the
  same valence as in the pattern graph. See the issue below about tassles for
  the motivation.

  NOTE: Tried this and it's not very useful. See below in tassles.

- Need some more control parameters:
  - Apply a particular rule only once. Good for special rules.
  - Weight the choice of particular rules.
  - Try and control the cardinality of certain tags. Consider a level that has
    three main sections and you want them to be equally developed. The current
    random rule selection makes that hard to achieve without some complex tag
    assignments.

- Should pass the graph to a Constraint Propagation Solver (CPS) so we can
  allow for some cunning logic to be applied (maybe before the relax stage):
  - What type of room generation to employ.
  - What sizes the room should be.
  - Could allow edges to be removed (made cosmetic) as long as the graph is
    still connected.
  - Where to place entrances, exits, keys, monsters, treasure, doors and so on.

Some unresolved issues:
-----------------------

- It's easy to cause issues by connecting edges in the substitute graph that
  aren't connected in the pattern, e.g.

  a - b     a - b
      |  =>   \ |
      c         c

  It can easily create 'knots' that the graph drawing can't undo. Might be
  worth stopping this from happening by adding another condition on the rules.

  Actually this is sometimes very useful, so caveat emptor.

- It's too easy to create 'tassles', e.g.

  a - b     a - b
    \ |  =>   \ |
      b         b - c

  The above can be matched to the same part of the host graph many times so you
  can get a lot of 'c' vertices hanging off the same 'b' vertex. Could be fixed
  by changing the tag of the 'b' vertex that 'c' is attched to though.

  This issue also made me consider a rule that any vertex that changes valence
  in the substitute must have the same valence in the host graph as it does in
  the pattern. This would stop tassles but also make obviously fine rules not
  work as intended, e.g.

               b
              / \
  a - a  =>  a   a
              \ /
               b

  The 'a' vertices increase in valence but so this rule could only be applied
  to a host graph that looked exactly like the pattern graph.

  Could add the valence rule as a optional vertex attribute though. In fact I
  think this might be the best solution...

  Actually this isn't a great solution. You need to add a lot of extra guff to
  the pattern graph to make it work, which reduces flexibility.

  A better solution might be something I've seen in a few graph grammar systems
  where you can specify vertices that shouldn't be in the host, e.g.

  a - b         a - b
    \ |      =>   \ |
      b - !c        b - c

  The !c means don't match if there's a c tagged vertex connected to the lower
  'b' vertex. This will be tricky to implement though:

  - The blocked nodes shouldn't appear in the actual matching graph otherwise
    it will only match graphs with an extra neighbour but just only if it's not
    tagged as 'c'.
  - The following case could cause issues:

    a - b         a - b
      \ |      =>   \ |
        b - !b        b - b

    The matching would have to be able to distinguish between the higher b in
    the pattern and the blocked b.

  So here's a rough algorithm:
  - A pattern vertex is allowed only one blocked neighbour and a blocked
    vertex can only be attached to one non-blocked vertex.
  - Allow an extra argument to the rules that is a map from pattern vertices to
    a blocked peer tag (or tag sets).
  - In GraphGrammer.Rule:matches() there's a filtering step.
    - If the rule has any blocked vertices.
      - Find the edges in the host not matched.
        - For all matched vertices
          - Is their a peer of the graph vertex not in the match
            - Add the edge to the unmatched peer to the list.

- Sometimes the valence of vertices gets too high for the graph drawing to
  handle, e.g.

  a - b     a - b
    \ |  => | \ |
      b     b - b

  Can subdivide add an extra spoke to a 'wheel' of triangles indeifnitely.
  Eventually the circumference of the wheel will collapse and edges start
  intersecting. May be worth adding a maxValence paramter to the builder so
  that this isn't allowed to happen. In any case we don't want the valence to
  get too high for gameplay reasons anyway.

  Could be a per-vertex attribute I suppose but feels a little untidy.

  Also I think the cause of the issue is that the spring forces in the graph
  drawing are very strong when the edge is too short. This pushes other edges
  into overlapping positions.

  NOTE: maxValence has been added as a build parameter.

- What about setting edge length factors at the end of each force draw?

  This is a pretty random idea, not sure what the purpose was...

- There is an issue with subdividing rules. Because the desired edge length for
  all edges is the same it is common for the 'inside' vertices of a subdivding
  substitute graph to be pushed outside.

  It would be possible to control this with a per-edge 'length factor' that
  multiplies the base desired edge length. If the internal edges of the
  substitute graph have length factors less than 1 it should hold the internal
  vertices in place.

  One problem with that is that rules can be recursively applied and length
  factors are absolute. So if a subdividing rule is applied twice the same
  problem will reappear.

  This can be combatted by calculating the mean length factor of the matched
  part of the host graph.

  If the edge is not marked as 'subdivided' the length factor is 1.

  When adding substitute edges we have the following properties:
  - Mapped. The vertices of the substitute edge are both mapped and an edge
    exists between them in the pattern. Such edges use the length factor of the
    host edge it replaces.
  - Subdivided edge. The susbstitute edge is marked as subdivided and has a
    length factor specified. This has to be multiplied by the mean length
    factor.
 
  NOTE: implemented a first pass of this, seems to work reasonably well but it
        goes wrong if there's too much subdivision going on. As a rule of thumb
        it starts to break down after three subdivisions.

- The circle relaxing pass can make vertices that aren't connected intersect.
  It might be worth adding cosmetic edges between all unconnected nodes to stop
  this happening but we'd need to somehow define an edge length between them.

  NOTE: this doesn't seem to work at all. The extra edges just pull everthing
        into a ball.

  NOTE: I added the circle radii to the repulsion stage of the graph drawing,
        seems to work most of the time.


- Different rulesets need to be able to have different tuning paramters and
  constraints.

- So there's an issue with the relax stage of the force drawing. It leaves
  vertices spaced too far out.

  Managed to control is a bit better by changing relax parameters.



Metarules or Rules for applying Rules
=====================================

While it is possible to use clever tag assignments and features like negated
tags to control the application of rules this is not always the most direct
way. For example consider a rule that be recursively applied:

  a - a    a - a - a
  |   | => |   |   |
  a - a    a - a - a

If by random chance this rule was applied a lot it would create a long sequence
of quads. You could limit it by using a set of rules, e.g.

  a - a    b - b - b
  |   | => |   |   |
  a - a    b - b - b

  a - a    b - b - b - b
  |   | => |   |   |   |
  a - a    b - b - b - b

  a - a    b - b - b - b - b
  |   | => |   |   |   |   |
  a - a    b - b - b - b - b

The above would only crate between 2 and four quads. However it seems a lot
simpler to just say that the original rule cannot be applied more than twice.

Ideas
-----

- Min and max uses: would be easier to just do max uses because you can't
  guarantee that all min uses will be possible beforehand. Also certain prior
  rule choices may stop underused rule from being used.

  It may be possible to do a prepass on the ruleset to detect this but it feels
  like a nasty problem that may be intractable or very inefficient.

- Don't repeat: not the same as a max use of 1, it means don't use the rule
  twice in a row.

- Combined max usage: You may want only one of a set of rules applied.

- Priorities: after all rules have been checked for other constraints use the
  higest priority.

- Passes: sets of rules to be applied in certain orders.

TODO: need some discussion about using CPS during generation.

